package AllTypesTestDoublesEx;

import AllTypesTestDoublesEx.Dummy.OrderProcessor;
import org.junit.jupiter.api.Test;

public class OrderProcessorTest {

// Dummy - фиктивный обьект(никакой реальной логики)нет ответов
//    обьекты передаются, но никогда не используются, просто для заполнения, пустышка по факту;ЗАПОЛНИТЕЛЬ!
//    Фиктивные обьекты используются в качестве заменителя , чего -то ,
//    может быть для заполнения аргументов, методов или классов.
//    Мы используем, когда нам не важно реальное содержимое,
//    чтобы просто был.На примере проверить сохранение в бд, нужен какой то товар,
//    какой то класс, обьект.Мы хотим изолировать тестируемый код от разных зависимостей,
//    зависимость будет выступать реальный  обьект, мы не хотим его реально создавать.
//    Полезным , это заполнение аргументов, тоесть в некоторых случаях, чтобы вызвать метод
//    или конструктор.В качестве аргумента нам требуется обьект- мы ставим обьект(фективную заглушку)
//    также используется для создания, когда не важно что конкртено внутри этого оьбекта.

    @Test
    void testProcessOrder() {
// Создаем фиктивный объект Order (Dummy)
       // Order dummyOrder = createDummyOrder();

// Создаем экземпляр OrderProcessor
        OrderProcessor orderProcessor = new OrderProcessor();

// Вызываем метод processOrder, передавая фиктивный объект Order
      //  orderProcessor.processOrder(dummyOrder);

// Здесь можно добавить утверждения (assertions) для проверки поведения метода
// Например, можно утверждать, что метод отправил уведомление клиенту и т.д.
    }


//     метод для создания фиктивного обьекта
//    private Order createDummyOrder() {
//        Order dummyOrder = new Order();
// Заполняем фиктивные данные для объекта Order
//        dummyOrder.setOrderId(1);// по идеи этот метод должен быть в оригинальном классе OrderProcessor
//        dummyOrder.setCustomerName("John Doe"); // по идеи этот метод должен быть в оригинальном классе OrderProcessor
//        return dummyOrder;
//    }
}